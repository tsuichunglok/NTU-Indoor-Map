{"version":3,"sources":["../../src/algos/BFS.js"],"names":[],"mappings":";;;;;;;;AAAA;;AAEA,SAAS,GAAT,CAAa,KAAb,EAAoB,IAApB,EAA0B;AACtB,QAAM,UAAU,SAAc,EAAE,SAAS,MAAT,EAAhB,EAAmC,IAAnC,CAAV,CADgB;AAEtB,QAAM,UAAU,QAAQ,OAAR,CAFM;;AAItB,aAAS,UAAT,GAAsB;AAClB,cAAM,aAAN,CAAoB,UAAS,CAAT,EAAY;AAC5B,mBAAO,EAAE,OAAF,CAAP,CAD4B;SAAZ,CAApB,CADkB;KAAtB;;AAMA,aAAS,IAAT,CAAc,CAAd,EAAiB;AACb,UAAE,OAAF,IAAa,IAAb,CADa;KAAjB;;AAIA,aAAS,QAAT,CAAkB,CAAlB,EAAqB;AACjB,eAAO,EAAE,OAAF,MAAe,IAAf,CADU;KAArB;;AAIA,QAAM,0BAA0B;AAC5B,iCAD4B;AAE5B,iBAAS,iBAAS,CAAT,EAAY,EAAZ;AACT,oBAAY,oBAAS,CAAT,EAAY,EAAZ;AACZ,oBAAY,IAAZ;AAJ4B,KAA1B,CAlBgB;;AAyBtB,WAAO;;;;;;AAKH,oCAAS,QAAQ,MAAM;AACnB,gBAAM,UAAU,SAAc,EAAd,EAAkB,uBAAlB,EAA2C,IAA3C,CAAV,CADa;;AAGnB,yBAHmB;;AAKnB,gBAAM,QAAQ,EAAR,CALa;AAMnB,kBAAM,IAAN,CAAW,MAAX,EANmB;AAOnB,iBAAK,MAAL,EAAa,IAAb,EAPmB;AAQnB,gBAAI,UAAJ;gBAAO,UAAP;gBAAU,cAAV,CARmB;;AAUnB,mBAAM,MAAM,MAAN,GAAe,CAAf,EAAkB;AACpB,oBAAI,MAAM,KAAN,EAAJ,CADoB;AAEpB,wBAAQ,OAAR,CAAgB,CAAhB,EAFoB;AAGpB,wBAAQ,MAAM,aAAN,CAAoB,CAApB,EAAuB,QAAQ,SAAR,EAAmB,QAAQ,UAAR,CAAlD,CAHoB;AAIpB,sBAAM,OAAN,CAAc,UAAS,CAAT,EAAY;AACtB,4BAAQ,UAAR,CAAmB,CAAnB,EADsB;AAEtB,wBAAI,QAAQ,SAAR,GAAoB,EAAE,EAAF,GAAO,EAAE,IAAF,CAFT;AAGtB,wBAAG,CAAC,SAAS,CAAT,CAAD,EAAc;AACb,6BAAK,CAAL,EADa;AAEb,8BAAM,IAAN,CAAW,CAAX,EAFa;qBAAjB;iBAHU,CAAd,CAJoB;aAAxB;SAfD;KAAP,CAzBsB;CAA1B;;kBAyDe","file":"BFS.js","sourcesContent":["import { OUT } from '../core/constants.js';\n\nfunction BFS(graph, opts) {\n    const options = Object.assign({ flagKey: '_bfs' }, opts);\n    const flagKey = options.flagKey;\n\n    function clearFlags() {\n        graph.forEachVertex(function(v) {\n            delete v[flagKey];\n        });\n    }\n\n    function mark(v) {\n        v[flagKey] = true;\n    }\n\n    function isMarked(v) {\n        return v[flagKey] === true;\n    }\n\n    const defaultTraversalOptions = {\n        direction: OUT,\n        onVisit: function(u) { },\n        onTestEdge: function(e) { },\n        edgeFilter: null    // take all edges\n    };\n\n    return {\n        /**\n        Traverse the graph using the breadth first algorithm,\n        starting from source, with the specified options\n        */\n        traverse(source, opts) {\n            const options = Object.assign({}, defaultTraversalOptions, opts);\n\n            clearFlags();\n\n            const queue = [];\n            queue.push(source);\n            mark(source, null);\n            let u, v, edges;\n\n            while(queue.length > 0) {\n                u = queue.shift();\n                options.onVisit(u);\n                edges = graph.incidentEdges(u, options.direction, options.edgeFilter);\n                edges.forEach(function(e) {\n                    options.onTestEdge(e);\n                    v = options.direction ? e.to : e.from;\n                    if(!isMarked(v)) {\n                        mark(v);\n                        queue.push(v);\n                    }\n                });\n            }\n        }\n    };\n}\n\nexport default BFS;\n"]}