{"version":3,"sources":["../../src/algos/DijkstraIterator.js"],"names":[],"mappings":"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","file":"DijkstraIterator.js","sourcesContent":["import PriorityQueue from 'updatable-priority-queue';\nimport NodeFlagger from './nodeFlagger.js';\nimport { OUT, SETTLED, REACHED } from '../core/constants.js';\n\nclass DijkstraIterator {\n    static defaultOptions = {\n        flagKey: '_dijkstra',\n        direction: OUT,\n        shouldUpdateKey: (prevCost, newCost) => { return newCost < prevCost; },\n        edgeCost: (e, costDone) => 1,\n        heuristic: v => 0,\n        onReach: null,        // nothing special to do when reaching a node\n        onSettle: null,     // nothing special to do when setting a node\n        edgeFilter: null    // take all edges\n    }\n\n    constructor(graph, source, opts) {\n        this.graph = graph;\n        this.source = source;\n        this.options = Object.assign({}, DijkstraIterator.defaultOptions, opts);\n        this.flags = new NodeFlagger(this.graph, this.options.flagKey);\n\n        this.pQ = new PriorityQueue();\n        this._initTraversal();\n    }\n\n    _reach(v, incEdge, fCost, gCost, action) {\n        // update state to \"reached\", and register cost and incomingEdge\n        this.flags.setFlags(v, {state: REACHED, fCost, gCost, inc: incEdge});\n        if (action) {\n            action(v);\n        }\n    }\n\n    _settle(v, action) {\n        this.flags.setFlags(v, {state: SETTLED});\n        if (action) {\n            action(v);\n        }\n    }\n\n    _initTraversal() {\n        // reset node tagging\n        this.flags.clearFlags(this.graph);\n        this.pQ.insert(this.source, this.options.heuristic(this.source));\n        this._reach(this.source, null, this.options.heuristic(this.source), 0, this.options.onReach);\n    }\n\n    next() {\n        // if no more node available in the queue,\n        // return the iterator end signal\n        if (this.pQ.count === 0) {\n            return { done: true };\n        }\n\n        const {\n            direction,\n            onReach,\n            onSettle,\n            edgeFilter,\n            edgeCost,\n            heuristic,\n            shouldUpdateKey\n        } = this.options;\n\n        const u = this.pQ.pop().item;\n        let v;\n        let vFlags;\n        const uGCost = this.flags.getFlags(u).gCost;\n        let vFCost, vGCost;\n\n        this._settle(u, onSettle);\n        const edges = this.graph.incidentEdges(u, direction, edgeFilter);\n        for (let e of edges) {\n            v = direction === OUT ? e.to : e.from;\n            vFlags = this.flags.getFlags(v);\n\n            if (vFlags.state !== SETTLED) {\n                vGCost = uGCost + edgeCost(e, uGCost);\n                vFCost = vGCost + heuristic(v);\n                if (vFlags.state !== REACHED) {\n                    this.pQ.insert(v, vFCost);\n                    this._reach(v, e, vFCost, vGCost, onReach);\n                } else {\n                    if (shouldUpdateKey(vFlags.fCost, vFCost, vFlags.inc, e)) {\n                        this.pQ.updateKey(v, vFCost);\n                        this._reach(v, e, vFCost, vGCost, onReach);\n                    }\n                }\n            }\n        }\n\n        return { value: u };\n    }\n};\n\nexport default DijkstraIterator;\n"]}