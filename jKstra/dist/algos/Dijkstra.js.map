{"version":3,"sources":["../../src/algos/Dijkstra.js"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;;;IAEM;AACF,aADE,QACF,CAAY,KAAZ,EAAmB,IAAnB,EAAyB;8BADvB,UACuB;;AACrB,aAAK,KAAL,GAAa,KAAb,CADqB;AAErB,aAAK,OAAL,GAAe,SAAc,EAAE,SAAS,WAAT,EAAhB,EAAwC,IAAxC,CAAf,CAFqB;AAGrB,aAAK,WAAL,GAAmB,0BAAgB,KAAK,KAAL,EAAY,KAAK,OAAL,CAAa,OAAb,CAA/C,CAHqB;KAAzB;;iBADE;;oCAOU,KAAK;AACb,gBAAM,QAAQ,EAAR,CADO;AAEb,gBAAI,aAAJ;;AAFa,mBAIN,CAAC,OAAO,KAAK,WAAL,CAAiB,QAAjB,CAA0B,GAA1B,EAA+B,GAA/B,CAAR,KAAgD,IAAhD,EAAsD;AACzD,sBAAM,IAAN,CAAW,IAAX,EADyD;AAEzD,sBAAM,KAAK,IAAL,CAFmD;aAA7D;AAIA,mBAAO,MAAM,OAAN,EAAP,CARa;;;;;;;;;qCAkBJ,QAAQ,QAAQ,MAAM;;;AAC/B,gBAAM,UAAU,QAAQ,EAAR,CADe;AAE/B,oBAAQ,UAAR,GAAqB;uBAAM,MAAK,WAAL,CAAiB,QAAjB,CAA0B,MAA1B,EAAkC,KAAlC;aAAN,CAFU;;AAI/B,gBAAM,QAAQ,KAAK,QAAL,CAAc,MAAd,EAAsB,OAAtB,CAAR,CAJyB;AAK/B,gBAAG,KAAH,EAAU;AACN,uBAAO,KAAK,WAAL,CAAiB,MAAjB,CAAP,CADM;aAAV;AAGA,mBAAO,IAAP,CAR+B;;;;;;;;;;iCAe1B,QAAQ,MAAM;AACnB,gBAAM,UAAU,SAAc,EAAd,EAAkB,SAAS,uBAAT,EAAkC,IAApD,CAAV,CADa;AAEnB,gBAAM,mBAAmB,+BAAqB,KAAK,KAAL,EAAY,MAAjC,EAAyC,IAAzC,CAAnB;;;AAFa,mBAKb,CAAC,iBAAiB,IAAjB,GAAwB,IAAxB,IAAgC,CAAC,QAAQ,UAAR,EAAD,EAAuB,EAA9D;;;AALmB,mBAQZ,QAAQ,UAAR,EAAP,CARmB;;;;WAxCrB;;;SAkBK,0BAA0B;AAC7B,gBAAY;eAAM;KAAN;;AA+BnB;;kBAEc","file":"Dijkstra.js","sourcesContent":["import DijkstraIterator from '../algos/DijkstraIterator.js';\nimport NodeFlagger from './nodeFlagger.js';\nimport { SETTLED } from '../core/constants.js';\n\nclass Dijkstra {\n    constructor(graph, opts) {\n        this.graph = graph;\n        this.options = Object.assign({ flagKey: '_dijkstra' }, opts);\n        this.nodeFlagger = new NodeFlagger(this.graph, this.options.flagKey);\n    }\n\n    rebuildPath(end) {\n        const edges = [];\n        let edge;\n        // going upward in the tree until the first vertex (with no incoming edge)\n        while ((edge = this.nodeFlagger.getFlags(end).inc) !== null) {\n            edges.push(edge);\n            end = edge.from;\n        }\n        return edges.reverse();\n    }\n\n    static defaultTraversalOptions = {\n        isFinished: () => false\n    }\n\n    /**\n    The most common use of Dijkstra traversal\n    */\n    shortestPath(source, target, opts) {\n        const options = opts || {};\n        options.isFinished = () => this.nodeFlagger.getFlags(target).state === SETTLED;\n\n        const found = this.traverse(source, options);\n        if(found) {\n            return this.rebuildPath(target);\n        }\n        return null;\n    }\n\n    /**\n    Traverse the graph using Dijkstra's algorithm,\n    starting from source, with the specified options\n    */\n    traverse(source, opts) {\n        const options = Object.assign({}, Dijkstra.defaultTraversalOptions, opts);\n        const dijkstraIterator = new DijkstraIterator(this.graph, source, opts);\n\n        // simply loop over the iterator until it ends\n        while(!dijkstraIterator.next().done && !options.isFinished()) { }\n\n        // if false, means the whole graph was traversed\n        return options.isFinished();\n    }\n};\n\nexport default Dijkstra;\n"]}