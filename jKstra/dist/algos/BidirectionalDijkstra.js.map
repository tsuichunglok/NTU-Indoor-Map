{"version":3,"sources":["../../src/algos/BidirectionalDijkstra.js"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;AACA;;;;AACA;;;;;;IAEM;AACF,aADE,qBACF,CAAY,KAAZ,EAAmB,IAAnB,EAAyB;8BADvB,uBACuB;;AACrB,aAAK,KAAL,GAAa,KAAb,CADqB;AAErB,aAAK,OAAL,GAAe,SAAc,EAAd,EAAkB,IAAlB,CAAf,CAFqB;AAGrB,aAAK,MAAL,GAAc,eAAd,CAHqB;AAIrB,aAAK,KAAL,GAAa,cAAb,CAJqB;KAAzB;;iBADE;;oCAQU,aAAa;AACrB,gBAAM,QAAQ,EAAR,CADe;AAErB,gBAAI,aAAJ,CAFqB;AAGrB,gBAAI,cAAc,WAAd;;AAHiB,mBAKd,CAAC,OAAO,KAAK,UAAL,CAAgB,QAAhB,CAAyB,WAAzB,EAAsC,GAAtC,CAAR,KAAuD,IAAvD,EAA6D;AAChE,sBAAM,IAAN,CAAW,IAAX,EADgE;AAEhE,8BAAc,KAAK,IAAL,CAFkD;aAApE;AAIA,kBAAM,OAAN,GATqB;AAUrB,0BAAc,WAAd;;AAVqB,mBAYd,CAAC,OAAO,KAAK,SAAL,CAAe,QAAf,CAAwB,WAAxB,EAAqC,GAArC,CAAR,KAAsD,IAAtD,EAA4D;AAC/D,sBAAM,IAAN,CAAW,IAAX,EAD+D;AAE/D,8BAAc,KAAK,EAAL,CAFiD;aAAnE;AAIA,mBAAO,KAAP,CAhBqB;;;;8CAmBH,MAAM;AACxB,gBAAM,WAAW,KAAK,UAAL,CAAgB,QAAhB,CAAyB,IAAzB,CAAX,CADkB;AAExB,gBAAM,UAAU,KAAK,SAAL,CAAe,QAAf,CAAwB,IAAxB,CAAV,CAFkB;;AAIxB,mBAAO,CAAC,SAAS,KAAT,2BAA8B,SAAS,KAAT,uBAA9B,CAAD,KACC,QAAQ,KAAR,2BAA6B,QAAQ,KAAR,uBAA7B,CADD,CAJiB;;;;qCAQf,QAAQ,QAAQ,SAAS;AAClC,gBAAM,cAAc,+BAAqB,KAAK,KAAL,EAAY,MAAjC,EAChB,SAAc,EAAd,EACI,OADJ,EAEI,QAAQ,GAAR,EACA,EAAE,yBAAF,EAAkB,SAAS,KAAK,MAAL,EAH/B,CADgB,CAAd,CAD4B;AAOlC,gBAAM,aAAa,+BAAqB,KAAK,KAAL,EAAY,MAAjC,EACf,SAAc,EAAd,EACI,OADJ,EAEI,QAAQ,EAAR,EACA,EAAE,wBAAF,EAAiB,SAAS,KAAK,KAAL,EAH9B,CADe,CAAb,CAP4B;AAalC,iBAAK,UAAL,GAAkB,0BAAgB,KAAK,KAAL,EAAY,KAAK,MAAL,CAA9C,CAbkC;AAclC,iBAAK,SAAL,GAAiB,0BAAgB,KAAK,KAAL,EAAY,KAAK,KAAL,CAA7C,CAdkC;;AAgBlC,gBAAI,WAAW,WAAX,CAhB8B;AAiBlC,gBAAI,oBAAJ,CAjBkC;AAkBlC,gBAAI,aAAJ;;;AAlBkC,mBAqB3B,CAAC,CAAC,OAAO,SAAS,IAAT,EAAP,CAAD,CAAyB,IAAzB,EAA+B;AACnC,oBAAG,KAAK,qBAAL,CAA2B,KAAK,KAAL,CAA9B,EAA2C;AACvC,kCAAc,KAAK,KAAL,CADyB;AAEvC,0BAFuC;iBAA3C;;AADmC,wBAMnC,GAAW,aAAa,WAAb,GAA2B,UAA3B,GAAwC,WAAxC,CANwB;aAAvC;;AASA,gBAAI,WAAJ,EAAiB;AACb,uBAAO,KAAK,WAAL,CAAiB,WAAjB,CAAP,CADa;aAAjB;AAGA,mBAAO,IAAP,CAjCkC;;;;WAnCpC;;;AAsEL;;kBAEc","file":"BidirectionalDijkstra.js","sourcesContent":["import DijkstraIterator from '../algos/DijkstraIterator.js';\nimport NodeFlagger from './nodeFlagger.js';\nimport { IN, OUT, REACHED, SETTLED } from '../core/constants.js';\n\nclass BidirectionalDijkstra {\n    constructor(graph, opts) {\n        this.graph = graph;\n        this.options = Object.assign({}, opts);\n        this.outKey = '_dijkstra_out';\n        this.inKey = '_dijkstra_in';\n    }\n\n    rebuildPath(meetingNode) {\n        const edges = [];\n        let edge;\n        let currentNode = meetingNode;\n        // going upward in the tree until the first vertex (with no incoming edge)\n        while ((edge = this.outFlagger.getFlags(currentNode).inc) !== null) {\n            edges.push(edge);\n            currentNode = edge.from;\n        }\n        edges.reverse();\n        currentNode = meetingNode;\n        // going upward in the tree until the first vertex (with no incoming edge)\n        while ((edge = this.inFlagger.getFlags(currentNode).inc) !== null) {\n            edges.push(edge);\n            currentNode = edge.to;\n        }\n        return edges;\n    }\n\n    _hasBeenReachBothWays(node) {\n        const outState = this.outFlagger.getFlags(node);\n        const inState = this.inFlagger.getFlags(node);\n\n        return (outState.state === REACHED || outState.state === SETTLED)\n            && (inState.state === REACHED || inState.state === SETTLED);\n    }\n\n    shortestPath(source, target, options) {\n        const outIteraror = new DijkstraIterator(this.graph, source,\n            Object.assign({},\n                options,\n                options.OUT,\n                { direction: OUT, flagKey: this.outKey })\n        );\n        const inIterator = new DijkstraIterator(this.graph, target,\n            Object.assign({},\n                options,\n                options.IN,\n                { direction: IN, flagKey: this.inKey })\n        );\n        this.outFlagger = new NodeFlagger(this.graph, this.outKey);\n        this.inFlagger = new NodeFlagger(this.graph, this.inKey);\n\n        let iterator = outIteraror;\n        let meetingNode;\n        let next;\n\n        // simply loop over the iterator until it ends\n        while (!(next = iterator.next()).done) {\n            if(this._hasBeenReachBothWays(next.value)) {\n                meetingNode = next.value;\n                break;\n            }\n            // alternate between the two iterators\n            iterator = iterator === outIteraror ? inIterator : outIteraror;\n        }\n\n        if (meetingNode) {\n            return this.rebuildPath(meetingNode);\n        }\n        return null;\n    }\n};\n\nexport default BidirectionalDijkstra;\n"]}